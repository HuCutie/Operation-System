# 管道
Linux中管道体现为“|”，例如下述命令将前一个命令的结果作为后一个命令的参数，查询名为“mysql”的进程：
```shell
ps auxf | grep mysql
```
`grep`代表`Global Regular Expression Printer`，作为查询正则表达式的命令。

## 管道的创建
管道的创建依赖于系统调用。所谓管道，就是内核中的一串缓存：
```C
int pipe(int fd[2]);
// 这里创建一个匿名管道，返回两个描述符，一个是用于读管道的fd[0]，一个是用于写入管道的fd[1]。匿名管道只存在于内存，而不是文件系统的一部分。
```
创建子进程。由于创建子进程时会复制父进程的文件描述符，同时为了避免混乱，关闭父进程的读口和子进程的写口。  
**因此，想要双向通信，需要两个管道。**  
在shell里执行`A | B`时，A，B都是shell的子进程，它们之间并无父子关系，都是shell的子进程。  
1. 对于匿名管道，通信范围是存在父子关系的进程，因为其管道无实体，只可通过`fork`赋值父进程的命名符，达到通信的目的；
2. 对于命名管道，在不相关的进程之间也可进行通信，因为其创建了一个设备文件，进程只要使用了这个文件，就可进行通信；  
# 消息队列
解耦，提升效率。  
消息队列保存在内核中的消息链表，发送时消息是以用户自定义的消息体格式存在的，且消息体的生存周期随着内核，只要是未释放消息队列或为关闭系统，那么消息就是一直存在。而管道的生存周期随着进程的释放而被销毁。  
消息队列有两个不足：
1. 消息体不能过大。Linux内核中两个宏定义`MSGMAX`和`MSGMNB`，以字节为单位，分别定义了一条消息的最大长度和一个消息队列的对大长度；
2. 存在用户态和内核态之间数据拷贝的开销；

# 共享内存
共享内存用于解决消息队列的频繁拷贝和写入带来的开销问题。  
现代操作系统对于内存管理都是采用虚拟内存的方式。及每个软件或应用无需关注物理内存的地址。  
共享内存，即是拿出一块虚拟内存地址，映射到同一块物理内存中。使得进程A写入的数据，进程B立马可以感知并可以直接使用，减少了拷贝的开销。

 # 信号量
 信号量用于解决共享内存带来的新问题，即多个进程同时修改一块虚拟内存的冲突问题。  
 为防止上述现象的发生，引入了信号量这个保护机制。  
 信号量是一个整型的计数器，表示资源数量。控制信号量的方式有两种原子操作，类似于数据库当中的锁，必须成对出现：  
1. P操作  
P操作在进入共享资源之前，这个操作会将信号量减1。相减后若信号量<0，则表明该资源已经被占用，进程需要阻塞等待；相反若≥0，则说明可正常使用；
2. V操作  
V操作在离开共享资源之后，这个操作会将信号量加1。相加后若信号量≤0，则表明当前有阻塞的进程，需要将改进程唤醒；相反若<0，则说明无阻塞进程；  

信号量的初始化，可根据使用场景，进行选择：  
1. 初始化信号量为1  
· 进程A在访问共享内存之前，执行P操作，使得信号量变为0，表示资源可用  
· 若此时进程B想要访问共享内存，执行P操作，使得信号量变为了-1，于是进程B进入了阻塞状态  
· 进程A访问结束，离开后执行V操作，使得信号量变为0，说明在阻塞队列中有等待的进程，于是唤醒进程B，同时B访问结束后，信号量又变成了1  
**所以，初始化信号量为1，代表互斥信号量，保证共享内存在任何时刻只有一个进程在访问。**
2. 初始化信号量为0  
· 进程B比进程A先执行，进程B的P操作使得信号量变为-1，B会直接进入阻塞  
· 若A进程先执行，其PV操作后信号量恢复为0，会唤醒阻塞的B  
**所以，初始化信号量为0，代表同步信号量，可以保证进程A在B之前执行**  
# 信号
信号与信号量没有任何关系。上述的进程间通信，均是发生在常规工作状态。对于异常状态下的工作模式，就需要使用信号的方式通知进程。
```shell
kill -l
```
上述命令可以查看得到Linux系统中所有的信号，共64种。  
如我们在终端中，`Ctrl + C`产生`SIGINT`信号，代表终止该进程；  
`Ctrl + Z`产生`SIGTSTP`信号，代表停止该进程，但不结束；  
所以信号的来源主要有硬件和软件。  
信号是进程间通信机制中唯一的异步通信机制，因为我们可以在进程运行的任一时间发送信号。信号一旦被接收，有如下3种处理方式：  
1. 执行默认操作。Linux对每种信号都定义了默认操作。  
2. 捕捉。将信号定义为一个触发器，一旦接收，执行某个信号处理函数。  
3. 忽略。直接忽略信号，但`SIGKILL`和`SIGSTOP`是进程无法捕捉和忽略的。

# Socket
管道、消息、共享内存、信号量和信号均是在同一主机上进行的进程间通信。若想要跨网络进行通信，则需要使用Socket通信。Socket当然也可以用于同一主机上。  
Socket的系统调用用如下：
```C
int socket(int domain, int type, int protocal);
// domain代表协议族。如AF_INET用于IPv4、AF_INET6用于IPv6、AF_LOCAL/AF_UNIX用于本机
// type指明通信特性。SOCK_STREAM表示字节流，对应TCP、SOCK_DGRAM对于UDP数据报、SOCK_RAW使用原始套接字
// protocal原本用于指定通信协议，但现在基本废弃，给0即可
```
**针对3种方式，进行一个过程的描述：**  
1. TCP  
![](0.%20Images/TCP.png) 
· 服务端和客户端初始化`socket`，得到文件描述符  
· 服务端调用`bind`，将IP地址绑定在端口  
· 服务端调用`listen`，进行监听  
· 服务端调用`accept`，等待客户端的连接  
· 客户端调用`connect`，向服务端的地址和端口发起连接请求  
· 服务端`accept`返回用于传输`socket`的文件描述符  
· 客户端调用`write`写入数据，服务端调用`read`读取数据  
· 客户端断开连接后，会调用`close`，此时服务端读取数据时会得到`EOF`；处理完数据后，服务端调用`close`，关闭连接  
**所以，该种方式下会使用到两个socket。连接建立之后，使用read和write进行数据的读写，就像操作文件流一样。**  
2. UDP  
![](0.%20Images/UDP.png)  
UDP无需建立连接，因此也不需要三次握手，只需要`bind`地址和端口。  
但相对应的，每次通信都需要调用`sendto`和`recvfrom`来传入目标主机的地址和端口。  
3. 本地  
与上述2种方式最大的不同，就是每次绑定一个本地文件。