# 死锁
## 死锁出现的场景
**死锁只有在同时满足下述4个条件才会出现：**
1. 互斥  
多个线程不能使用同一资源。
2. 持有并等待  
线程A持有资源1，同时想持有资源2，但资源2被线程B持有。这个时候线程会会进入等待状态，且期间仍会持有资源1.
3. 不可剥夺  
线程持有资源后，在自己使用完之前不会释放。
3. 环路等待  
多个线程获取资源的顺序构成了环路。

## 避免死锁的出现
**破坏上述任一条件，死锁机会被消除。常见的可行的办法是资源有序分配法。**  
资源有序分配法，是指让线程双方以同一顺序去访问资源，破坏环路。

# 互斥锁 自旋锁
· 互斥锁是一种独占形式的锁。其加锁失败后，线程会被释放，自身进入阻塞。其开销成本为2次的上下文切换；
· 自旋锁加锁失败后，线程会进入忙等待，直至拿到该锁。需要注意的是，单CPU是无法直接使用自旋锁的，因为忙等待状态下的线程不会放弃CPU的占用。因此需要一个抢占式的调度器，用于执行其它线程。自旋锁通过CPU提供的`CAS(Compare and Swap)`函数实现，在用户态进行加解锁，开销会更小。

# 读写锁
· 当写锁没有被占有时，多个线程能够并发的持有读锁；  
· 当谢所被某个线程占有后，读线程和其它写线程都会被阻塞；  
**所以，写锁像是独占锁，读锁像是共享锁。**  
## 读优先锁
读优先锁服务于读操作，旨在能够提供更多的读并发量。  
线程A持有读锁后，线程B此时想获取写锁时会被阻塞，但后序的线程C仍然可以获取到读锁。
## 写优先锁
写优先锁服务于写操作，旨在让写操作能够更快的被执行。  
线程A持有读锁后，线程B此时想获取写锁时会被阻塞，且后序的线程C也获取不到读锁。这样在线程A释放锁后，立马可以被线程B获取到写锁。  
**上述两种优先锁均可能出现`饥饿`现象。不偏袒任何一方，可以使用公平读写锁。**  
公平读写锁会将每次的读写锁获取请求放进队列，按照先进先出的原则，挨个进行授予。  

# 乐观锁与悲观锁
互斥锁、自旋锁、读写锁，均属于悲观锁。  
悲观锁认为，多线程访问同一资源时，很容易出现冲突，因此需要上锁。  
乐观锁几乎是无锁。其工作方式是：先修改资源，并验证在这段时间内有没有出现冲突，有冲突就放弃本次操作。使用场景如在线文档、如git。