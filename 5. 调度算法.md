# 进程调度
## 进程调度的情景有以下4种
1. 运行->阻塞
2. 运行->就绪
3. 阻塞->就绪
4. 运行->终止  
**其中1,4为非抢占式调度，2,3为抢占式调度。**

# 页面置换
## 缺页异常
**当CPU访问的页面不在物理内存中时，就会引发缺页异常。缺页异常的处理流程如下图所示：**  
![](0.%20Images/Page%20fault%20exception.png)  
上图中步骤④需要寻找空闲内存。若找不到，就需要页面置换，选择一个物理页面置换至磁盘。其目标是：尽可能的减少页面换入换出的次数。常见的页面置换算法有以下5种：  
1. 最佳页面(OPT)  
置换在未来最长时间不被访问的页面。  
因此需要计算内存中每个页面的下次访问时间，比较后进行选择。  
**这只是一种理论上的检测算法，因为实际场景中内存页的访问是动态变化的，是无法预知某个内存页再次被使用的时间的。**
2. 先进先出(FIFO)  
置换在内存中存在时间最长的页面。  
**性能过差**
3. 最近最久未使用(LRU)  
置换在内存中最长时间未被使用的页面。  
**开销较大**
4. 时钟页面(Clock)  
时钟算法综合了FIFO和LRU，也是将最近最久未使用的置换出去。  
时钟算法将所有页面保存在环形链表中，使用一个指针指向存在时间最长的页面。  
当内存中有空闲位置时，向链表中插入页面，访问位置1；  
当命中内存中的页面时，不进行操作，访问位仍是1；  
当发生缺页中断时，首先检查指针指向的页面：  
· 若访问位为0，则换出改页面，同时指针向后移动一位；  
· 若访问位为1，则清楚访问位，同时指针向后遍历，直至找到访问位为0的页面；  
在此基础上可进行进一步优化：
增加一个修改位，修改过置1，未修改过置0，和访问位会组成一个二元组，共有4中可能：  
· 访问位=0， 修改位=0，此时被置换的优先级最高；  
· 访问位=1， 修改位=0，优先级第二；  
· 访问位=0， 修改位=1，优先级第三；  
· 访问位=1， 修改位=1，优先级最低；  
5. 最不常用(LFU)  
置换在内存中访问次数最少的页面。  
对每个页面，都添加一个计数器，被访问时计数器自增1，发生缺页中断时置换出数值最小的那个页面。  
**对于计数器所需的开销，以及比较所需的开销，都是很大的。且只考虑了访问频率，未考虑访问时间（可通过定期减少计数器的数字进行缓解）。**

# 磁盘调度
**磁盘室友很多盘片组成的，每个盘片分为多个磁道，每个磁道又分为多个扇区。一个扇区是512字节。寻道是磁盘范文最费时的部分，因此磁盘调度算法旨在减少寻道距离。**  
1. FCFS  
简单粗暴，但性能上很差。  
2. SSF(Shortest Seek First)  
优先选择从当前磁头位置所需寻道时间最短的请求。  
**可能会产生饥饿，即某个比较远的磁道永远不会被访问到的情况。**  
3. 扫描  
类似于电梯，朝着一个方向移动，直至到达磁道末尾。  
**中间位置的磁道更占便宜。**  
4. 循环扫描  
磁头只在一个方向上工作，到达磁道末尾后直接复位返回。也就是只响应一个方向上的请求。  
5. LOOK和C-LOOK  
优化磁头的移动距离，使其执行完最后一条请求后就返回，而不是走到磁道末尾。  
· LOOK算法在两个方向上均响应请求；  
· C-LOOK算法旨在一个方向上响应请求，在另一个方向上仍然是迅速复位；