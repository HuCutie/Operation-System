# 虚拟内存
单片机等设备使用了绝对物理地址，这使得想要在内存中同时运行两个程序是完全不可能的，因为数据会被擦拭。未来解决上述问题，操作系统需要实现“虚拟内存”，让操作系统为每个进程分配一块虚拟地址，然后通过映射去找到物理地址。
## 管理虚拟地址与物理地址主要有方式
### 内存分段  
分段机制下的虚拟地址由两部分组成：段选择因子和段内偏移量。  
段选择因子保存在段寄存器中，用作段表的索引。段表里存放有段基地址、段界限和特权等级等。  
段内偏移量的值在0~段界限之间。
分段解决了程序本身无需关心内存地址的问题，但出现了新问题：
1. 内存碎片  
   1G物理内存：游戏占用512M，浏览器占用256M，音乐占用128M。  
   此时关闭音乐，内存还剩下256M，倘若该256M并非连续的内存，而是分成两片的128M，则我们就无法启动一个需要占用200M的进程。  
   **内存碎片的问题有两处：**  
   * 外部：产生了许多不连续的小物理内存  
   * 内部：程序所有内存均被装载，但某些内存不会被经常使用，导致内存的浪费  
解决外部内存碎片的主要方式是内存交换，但会引起下面的问题。
2. 内存交换效率低  
   内存交换会将音乐占用的128MB写入硬盘，再从硬盘读进内存。且读进内存的位置是紧挨着游戏和浏览器的768M后，这样就有足够的空间开辟新进程了，Linux中的Swap区便是用于硬盘与内存进行交换的区域。  
   硬盘的读写速度是很慢的，因此会导致卡顿，使得内存交换效率低。
### 内存分页  
内存分页用于解决上述问题。分页是将虚拟内存和物理内存均分成一段段固定大小的内存页，在Linux中这个数值是4KB，其间的映射由页表来完成。页表存储在内存中，内存管理单元MMU完成映射工作。当进程访问的虚拟地址在页表中找不到时，系统会产生缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后返回用户空间，继续进程的执行。  
采用分页，释放的内存都是以页为单位，也就不会出现小进程无法启动的问题。
若内存不够，操作系统会将其它进程最近没被使用的内存页释放掉，暂时写入硬盘，成为Swap Out换出，需要时再Swap In换入。每次只需要交换少数的内存页，交换效率就得到了提升。  
更进一步，我们加载程序时也可按需加载，即需要使用到虚拟内存中的指令和数据时，才加载到内存中去。  
**在分页机制中，虚拟地址由页号和页偏移组成**  
同分段，页号是页表的索引，其中包含每页的基地址。

## 简单分页的缺陷
缺陷来自于空间。多进程的存在，意味着页表也会很大，且每个进程有用自己的页表。
1. 多级页表  
   32位系统中每个进程共有100多万张页表，每个页表项拥有4字节的数据项，也就是需要 大约4M内存空间。  
   现将100多万页表分为1024个一级页表，每个一级页表下拥有1024个二级页表，形成二级分页。  
   理论上来看，这样似乎会导致每个进程的页表内存更大，但由于局部性原理，单个程序很难用到4G内存，因此大多数二级页表都是空的，是会被交换到硬盘上的，这便是一个巨大的节约。  
   **64位操作系统的四级分页**
   * PGB全局页目录项
   * PUD上层页目录项
   * PMD中间页目录项
   * PTE页表项
2. TLB页表缓存  
   多级页表解决了空间上的问题，但是用多级页表也增加了几道工序，降低了转址速度，带来了时间上的开销。  
   利用程序的局部性，将常用页表存入专用缓存TLB(Translation Lookaside Buffer)

## 段页式内存管理
综合段式内存和页式内存，地址结构由段号、段内页号和页内偏移量组成。这样增加了硬件成本和系统开销，但提高了内存利用率。  
段页式内存地址->物理地址需要三次内存访问：
1. 访问段表
2. 访问页表
3. 加上偏移量