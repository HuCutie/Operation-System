# 进程
## 状态
* Running 运行
* Ready 可以运行，但是由于其它进程在运行儿暂时停止
* Blocked 等待事件响应

* New 进程正在被创建
* Exit 进程结束

## 进程控制块PCB
### 所包含信息
* 进程描述信息  
· 进程标识符  
· 用户标识符
* 进程控制和管理信息  
· 进程当前状态  
· 进程优先级
* 资源分配清单  
· 内存/虚拟内存地址、所打开文件的列表、所使用的I/O设备等信息
* CPU相关信息  
· CPU中各寄存器的值

**通常使用链表的方式对各个进程进行组织，把具有相同状态的PCB链在一起，形成队列。**  
**当然理论上也可使用索引或其它方式，但由于链表的创建和删除操作更加快捷，所以使用链表会比较多。**

## 进程的控制
* 创建  
· 为新进程分配唯一进程号，申请PCB。PCB的数量是有限的。  
· 为进程分配资源，若资源不足，则进行等待。  
· 对PCB进行初始化  
· 若该PCB被接纳，则插入调度队列，等待执行。
* 终止  
终止的方式主要有3种：正常结束、异常结束、外界干预  
· 查找PCB。  
· 若处于执行状态，则立马结束，直接回收其资源。  
· 若该进程下还有子进程，需要将子进程递归的进行终止。  
· 在队列中将该PCB删除。
* 阻塞
· 查找PCB。  
· 若处于运行状态，则保护现场，并将状态置为阻塞。  
· 添加至阻塞队列。
* 唤醒
· 在阻塞队列中查找PCB。  
· 移出阻塞队列，并将状态置为就绪。  
· 插入至就绪队列，等待执行。

## 进程的上下文切换
**对于CPU上下文切换来说，就是系统内核存储现有寄存器和程序计数器的状态，需要再次执行时恢复现场。**  
CPU上下文的切换可以分为：进程/线程/中断上下文切换。  
进程上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。  
**进程上下文切换的花销很关键，需要尽可能的小。**  
### 进程上下文切换的场景
· 时间片时间到了  
· 内存或其它系统资源不足时  
· 程序主动将自己挂起(sleep)  
· 执行高优先级任务  
· 发生硬件中断

# 线程
**线程是进程执行中的一条流程。**  
同一进程下的线程可以共享代码段、数据段等资源，同时每个线程自己拥有一套寄存器和栈，确保相对独立。  
* 优点
· 一个进程课拥有多个线程  
· 线程间并发执行  
· 线程间共享
* 缺点  
· 一个线程崩溃，会导致所属进程下的所有线程崩溃
## 进程与线程
1. 进程是资源分配的最小单位，线程是CPU调度的最小单位
2. 进程拥有完整的资源平台，线程只独享其必须的资源，如寄存器和栈
3. 进程和线程都具有相同的状态和转换图
4. 使用线程可以减少上下文切换的花销，体现在  
* 创建时，进程需要管理PCB中的信息，线程共享这些信息；
* 终止时，线程也只需要释放较少的资源；
* 切换时，进程需要切换页表，线程共享一个页表；
* 线程间的数据船体无需通过内核
## 线程的切换
· 若两个线程不属于同一进程，则相当于进程间切换  
· 若属于统一进程，只需切换独享的资源
## 线程的实现
**主要有3种实现线程的方式：**
1. 用户线程：多个用户线程对应一个内核线程  
用户线程是在用户空间实现的多线程，不涉及到内核，因此无法调用多个CPU核心同时运行多个线程。  
用户线程基于用户态的线程管理库实现，线程控制块TCB也是在库中实现，因此对操作系统而言，只可看到进程的PCB。所以，整个用户线程的管理和调度，操作系统并不直接参与。  
* 优点  
· 可用于不支持多线程技术的操作系统  
· 不涉及内核，响应速度快
* 缺点  
· 内核不参与，因此当某个线程阻塞，该进程下的所有现成全部阻塞  
· 内核不参与，因此当某个线程不交出CPU使用权，其余线程是没有一点办法的  
· 时间片是分给进程执行的，因此每个用户进程的时间片就更窄了，执行比较缓慢
2. 内核线程：一个用户线程对应一个内核线程
线程的创建和管理交由内核处理。  
* 优点
· 进程中的线程阻塞时不会影响其它线程
· 时间片分配给线程，因此执行时间更长，更迅速
* 缺点  
· 由内核维护PCB和TCB，增加了内核的压力  
· 线程的创建和管理也交由内核负责，系统开销较大
3. 轻量级进程：多个用户线程对应多个内核线程
结合上述两种方式，一个进程可拥有一个或多个轻量线程(Light Weight Process)LWP，每个LMP与内核一一对应。  
与普通进程相比，LWP相当于执行线程，只拥有一个最小的执行上下文和调度所需的统计信息。  
LMP可以使用用户线程，且有经典的3种对应方式。  
![](0.%20Images/LMP.png)
* 1:1  
如上图进程1和4。  
· 优点  
并行，不会被阻塞。  
· 缺点  
开销大。
* N:1  
如审图进程2.  
· 优点  
取消了线程数量的约束，且线程上下文的切换效率高。  
· 缺点  
会造成阻塞，且无法充分利用多核CPU的优势。
* M:N  
如上图进程3。  
· 优点  
添加了二级控制，结合了上述两种方式的优点，使得大部分的上下文切换发生在用户空间，减少内核压力，同时多内核线程可以充分发挥多核CPU的优势。
* 组合模式  
如上图进程5.  
结合了1:1和M:N模式，开发人员课根据具体需求动态调节内核线程的数目得到逻辑并行性和物理并行性的最佳方案。
# 调度
## 调度时机
1. 就绪态->运行态    
2. 运行态->阻塞态
3. 运行态->结束态  
同时，若使用硬件提供的时钟频率进行周期性的中断，那么根据如何处理中断，将调度算法分为两大类：  
· 非抢占式调度  
不理会中断，选择一个进程，直至阻塞或结束。  
· 抢占式调度  
使用时间片机制，在每个时间片末端处理中断，将进程挂起。
## 调度原则
1. 发送I/O时间导致CPU进入空闲的情况下，调度程序需要从就绪队列中挑选其它进程执行，提高CPU利用率。
2. 权衡长任务和短任务，提高系统吞吐率。
3. 避免发生进程等待时间很长而运行时间很短导致的周转时间过长的情况。
4. 就绪队列中进程的等待时间也是应当考虑的原则。
5. 对于交互式应用，响应时间也是应当考虑的原则。
## 调度算法
**单核CPU中：**
1. FCFS(First Come First Served)  
非抢占式算法，对长作业有利，适用于CPU繁忙而非I/O繁忙的系统。
2. SJF(Short Job First)  
优先选择执行时间短的进程执行，提高系统的吞吐量，对长作业极其不利。
3. HRRN(Highest Response Ratio Next)  
权衡长作业和短作业，通过计算响应比优先级，选择合适的进程执行：   
· 若等待时间相同，要求服务时间越短，则响应比优先级越高，此时考虑到了短作业；  
· 若要求服务时间相同，等待时间越长，则响应比优先级越高，此时考虑到了长作业； 
响应比优先级的计算公式为  
$$
 Priority = \frac {(Waiting Time + Requested Time)} {Requested Time} 
$$   
4. RR(Round Robin)  
时间片轮转算法，最古老，最简单，最公平，最广泛使用。  
每个进程被分配一个时间段，称为时间片(Quantum)：  
· 若时间片结束但进程仍在运行，则换入新的进程执行；  
· 若时间片未结束进程就已阻塞或结束，则立即换入新进程；  
因此，时间片长度的选取是很关键的：  
· 过短，CPU会频繁的进行上下文切换，降低CPU效率；  
· 过长，会使得短作业的响应时间变长；  
**一般来说，20ms-50ms是比较合理的折中值。**  
5. HPF(Highest Priority First)  
最高优先级算法，即从就绪队列中选取优先级最高的进程进行执行。  
进程的优先级可分为：  
* 静态优先级：创建时确定，整个运行过程中都不会改变  
* 动态优先级：动态调整优先级。若进程的执行时间增加，则降低其优先级；若等待时间增加，则增加其优先级，即随着时间推移增加等待进程的优先级  
该算法也分为抢占式和非抢占式，且有低优先级进程永远不会被执行到的风险。
6. MFQ(Multilevel Feedback Queue)  
多级反馈队列算法是RR和HPF算法的综合和发展。  
* 多级表示有多个队列，队列间的优先级从高到低，同时优先级越高时间片越短
* 反馈表示如若有新进程加入优先级较高的队列时，立即停止当前进程，转而执行优先级高的队列  
**对于短作业，可能在第一级队列就被处理完；**  
**对于长作业，虽然可能在下面几级队列才被执行到，但是增加了时间片的长度，因此兼顾了长短作业，保证了系统有较好的响应时间；**