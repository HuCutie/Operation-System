# Cache
### 内存数据结构  
1. 组标记  
   标志内存单元所在组，用于核对缓存中存放的是否为当前内存地址中的数据。
2. 索引  
   组内索引块。
3. 偏移量  
   块内偏移量。
![](../Operation%20System/0.%20Images/Memory%20and%20CPU%20cache.png)
根据CPU给出的上述内存数据结构，先去缓存中搜索数据。缓存数据结构多处一个标志位tag，用于标注该出缓存是否有效。若无效，则直接去内存中查询。

### 提升CPU性能
1. 增大CPU频率  
   摩尔定律已不再适用。
2. 增大缓存命中率  
   数据缓存命中率：缓存是成块的将内存数据加入的，因此编写程序时可考虑从数据存放位置入手进行优化，如二维数据赋值时，考虑`a[i][j]`的顺序而不是`a[]j[i]`。  
   指令缓存命中率：对单核CPU来说，分支预测器已基本能满足需求。对多核CPU来说，进程在不同核心间切换非常浪费时间，因此可以考虑将进程绑定在某一个CPU核心上。

### 数据一致性
#### 首先是考虑单核情况下的数据一致性：
1. 写直达  
   每次都更新Cache和Memory。
2. 写回  
   若命中，只写在Cache中，并且标记该数据为“dirty”。
   若命中，该缓存块里的数据是别的内存单元数据且为“dirty”，则需要将该条数据写入内存，之后再覆盖该缓存块，其继续标记为“dirty”。  
#### 多核情景中，多个进程访问同一缓存时需要做到以下两个要求：
1. 写传播  
   某个核心的Cache更新时，更新需要传播到其它核心。
2. 事务串行化
   某个核心对Cache进行的操作，在其它核心看来顺序是一样的。
   事务串行化也有两个要求：
   * CPU对Cache的操作需要同步给其它核心
   * 引入“锁”，在对Cache进行更新时只有拿到“锁”才可进行更新
#### 总线嗅探
某个CPU更新Cache时向总线发送广播，其它CPU监听广播事件，不过这加重了总线的负载，且无法保证事务串行化。
#### MESI协议
使用四个状态来标记Cache Line的四个状态：
* Modified，“dirty”标记，拥有此标记，代表此Cache数据已经得到了更新，但未写入内存。
* Exclusive，该条Cache只在该核心中出现，因此读写时无需通知其它核心，不存在一致性问题；且当其它核心读取了该条Cache后，状态便会变成“Shared”。
* Shared，更新该条Cache时需要发送广播，要求其它核心先将该条Cache标记为“Invalidtaed”，接着再更新。
* Invalidated，拥有此标记，代表此Cache数据已失效，不应当读取。  
有关MESI协议之间的状态转化，可以参考下面的状态转换图：  
![](0.%20Images/MESI.png)
**MESI协议中，“Exclusive”和“Modified”状态下的Cache在更新时是无需发送广播的，这在一定程度上减轻了总线负载。**

### 伪共享
当不同核心读取同一Cache Line的不同变量时，Cache就失去了作用。  
**解决方案**
* 对于可能经常被修改的数据，应避免这些数据出现在同一Cache Line中。即牺牲一个Cache Line的空间，使变量对齐在每个Cache Line的头部。
* 应用层面中，可使用一些字节填充＋继承的方式，确保其不会被伪共享。
![](0.%20Images/Case%20of%20avoiding%20flase%20sharing%20in%20JVM.png)
