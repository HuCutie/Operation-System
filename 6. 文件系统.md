**在计算机中，文件系统控制数据是如何存取的。如果没有文件系统，放置在存储介质中的数据将是一个庞大的数据主体，无法分辨一个数据从哪里停止，下一个数据又从哪里开始。通过将数据分为一块一块的，并为每一块都赋予一个名字，数据将会很容易隔离和确定。以纸质管理系统的命名方式命名，每一组数据就被称为文件。通过结构和逻辑规则来管理一组数据和名字，就被称为文件系统。**

# 文件系统的基本组成
Linux中，文件数据存储在磁盘的block中，文件系统会为每个文件分配两个数据结构：索引节点(index node)和目录项(directory entry)。  
· 索引节点，记录文件的元信息，如编号、大小、权限、位置等，是文件的唯一标识，也会被存储在磁盘中；  
· 目录项，记录文件名和索引节点指针以及与其它目录项的层级关系等。多个目录项关联起来就形成了目录结构。目录项由内核维护，缓存在内存中；  

## 硬链接和软链接
· 硬链接  
使用硬链接，使得源文件和目标文件有着一样的inode编号，可以有效防止误删操作；    
· 软链接  
软链接也叫符号链接，存储的是源文件的路径，也就是快捷方式；  

## 目录和目录项
· 目录  
目录本质上也是一个文件，其block部分记录着多个目录项，也就是文件名和inode；  
· 目录项  
文件名及其inode被称为目录项。

## 文件存储方式
磁盘读写的最小单位是扇区，其大小是512字节。倘若每次都以这个大小进行存取，那效率可想而知。因此文件系统将多个扇区组成一个逻辑块，其大小为4KB，以这个为最小单位进行读写。  
**另外，格式化磁盘时，会被分成3个区块，分别是超级块、索引节点区和数据块区：**  
1. 超级块  
存储文件系统的详细信息，如块数、块大小、空闲块数等。在文件系统挂载时加入内存。  
2. 索引节点区  
存储索引节点。在文件被访问时加入内存。  
3. 数据块区  
存储文件或目录文件的数据。  

# 虚拟文件系统
为了统一，操作系统在用户层和文件系统层之间加入了中间层，即虚拟文件系统。  
虚拟文件系统定义了一组所有文件系统都支持的数据结构和标准接口。

# 文件的存储
**和内存的连续与非连续分配相似。**
1. 连续空间存放方式  
· 优点：读取速度快  
· 缺点：容易造成碎片，且文件大小不易扩展  
2. 非连续空间存放方式  
* 链表  
· 隐式链表  
以隐式链表的方式存储文件，文件头需要包括文件第一块和最后一块的位置，这样，就可以类似于数据结构中的单链表，进行存储。其不足之处也和单链表一样，无法随机访问，只可遍历访问，且稳定性较差。  
· 显式链接  
取出每个数据块的指针，做成一张表放入内存，就可解决上述问题，这就是显式链接。显示链接需要在内存中维护一张文件分配表，有点像是数据结构中的邻接表。这种方式提高了检索速度，但并不适用于大磁盘，这样会小号大量内存空间。  
* 索引  
索引方式用于解决链表方式中无法很好实现的随机访问问题。索引的实现是为每个文件创建一个索引数据块，存放指向文件的指针列表，文件的文件头需要包含索引数据块的指针，用于找到该索引数据块。  
索引方式的优点有3个：  
· 文件的创建、增大、缩小很方便；  
· 无碎片化问题；  
· 支持顺序读写和随机读写；  
缺陷之一就是当文件很大，索引块需要的空间也就很大。通过结合上述2种方法，有如下解决方案：  
· 链式索引块。这种方式需要在每个索引数据块中留出一个存放下一索引块位置的指针；  
· 多级索引块。套娃方式；

# 空闲空间管理
对磁盘空闲空间的管理有3种方式：  
* 空闲表法  
为所有的空闲空间建立一张表，表中包含空闲空间第一个block的号以及空间块数。当磁盘请求分配空间时，便扫描这张表，找出合适的存储位置。是的，这种方式在大磁盘上效率很低，且只支持连续分配空间。  
* 空闲链表法  
与空闲表很类似，只不过使用了链表这种数据结构。大磁盘下，效率依然很低。  
* 位图法  
使用二进制数，对磁盘中区块的使用情况做一个说明。Linux中不仅使用位图进行磁盘空闲空间的管理，还进行了inode的管理。  

# 文件系统的结构
Linux文件系统的结构如下图：
![](0.%20Images/File%20System.png)  
因为一块的空间为4k，使用位图可以表示的空间只有128MB，把这个结构称作一个块组，多个块组来表示大文件。  
上图表示的是Linux Ext2文件系统的结构，包括以下部分：  
1. 引导块，在系统启动时用于引导。  
2. 超级块，包含inode个数等。  
3. 块组描述符，包含inode个数等，每个块组的块组描述符都包含了整个系统的信息。这么做是防止系统出现故障时可以进行恢复。  
4. 数据位图，表示块组中数据块的使用情况。  
5. inode位图，表示块组中inode的使用情况。  
6. 数据块，存储数据。

# 目录的存储
**目录也是文件，可以使用vim打开。通常第一项是`.`，第二项是`..`。**  
若目录有很多，查找也会出现效率问题。因此使用哈希表这种数据结构，将文件的文件名进行哈希运算，可以使得查找很快。同时为了减少I/O操作，将文件缓存在内存中，可以降低磁盘访问次数，提升系统运行效率。  

# 文件I/O
文件的读写方式主要有4种：  
1. 缓冲与非缓冲I/O  
缓冲，在这里指系统标准库内部实现的缓冲。  
· 缓冲I/O，利用系统标准库的缓存实现文件的加速访问，标准库中再进行系统调用；  
· 非缓冲I/O，直接走系统调用；  
很多程序在遇到换行后才进行输出，而换行前的内容就是被系统缓存了起来。这样可以减少系统调用的次数，即减少CPU上下文切换的开销。  
2. 直接与非直接I/O  
根据是否利用操作系统的缓存，将I/O方式分为直接与非直接：  
· 直接I/O，不发生内核缓存和用户数据之间的复制，直接通过文件系统访问文件；  
· 非直接I/O，读操作时，从内核缓存中拷贝给用户程序，写操作时，将用户程序拷贝给内核缓存，由内核缓存决定何时进行磁盘的写入；  
以下4种场景会触发啮合缓存写入磁盘的事件：  
· 调用`write`后，内核缓存太多；  
· 用户主动调用`sync`；  
· 内存资源紧张；  
· 缓存数据超过某个时间后；  
3. 阻塞与非阻塞I/O  
· 阻塞I/O，当用户执行`read`时，会等待内核将数据准备好+数据从内核态拷贝到用户态这两个过程，在此期间该线程是被阻塞的；  
· 非阻塞I/O，线程不停的去试探，直到数据准备好；  
· I/O多路复用，当内核数据准备好后，会以事件的形式通知程序；  
4. 同步与异步I/O  
· 上述3中的3种方式均属于同步I/O，因为无论是内核准备数据，还是拷贝数据，都是需要等待的；  
· 真正的异步I/O，两个过程均不需要阻塞等待，可以去做别的事。