# Linux系统中网络包的收发
## 网路模型
### OSI经典7层
· 应用层，负责给程序提供统一的接口  
· 表示层，负责把数据转换成兼容另一个系统能识别的格式  
· 会话层，负责建立、管理和终止表示层实体之间的通信会话  
· 传输层，负责端到端的数据传输  
· 网络层，负责数据的路由、转发、分片  
· 数据链路层，负责数据的封帧、差错检测，以及MAC寻址  
· 物理层，负责在物理网络中传输数据帧  

### 实际使用的TCP/IP 4层
· 应用层，负责向用户提供一组应用程序，如HTTPS、DNS、FTP等  
· 传输层，负责端到端的通信，如TCP、UDP等  
· 网络层，负责网络包的封装、分片、路由、转发，如IP、ICMP等  
· 网络接口层，负责网络包在物理网络中的传输，如包的封装、MAC寻址、差错检测、通过网卡传输网络帧等  

## 网络协议栈
应用数据在每一层的封装格式见下图：  
![](0.%20Images/Data%20Format.png)
在以太网中，规定了最大的传输单元(MTU)是1500字节，超过这个大小就需要在网络层分片。  

## Linux收发网络包的流程  
网卡是计算机中的一个硬件，专门负责接收和发送网络包。当网卡接收到网络包时，会通过DMA技术将其放入环形缓冲区(Ring Buffer)。  
当网速越来越快时，假如每次收发包都需要产生中断，那么CPU又会进入到饥饿状态。所以，在2.6之后的内核版本里，引入了NAPI机制，它混合了中断和轮询的思想，暂时屏蔽网卡的硬件中断，将数据放入缓冲区，软中断定时来取数据。这样，保证在一定时间内可以尽可能多的处理网络包。其思路和内存的缓冲区很像。  

# 零拷贝
**想要提高文件传输的性能，必须减少用户态与内核态上下文的切换以及内存拷贝的次数。**  
1. 减少系统调用的次数  
2. 用户缓冲区无需存在  
**传统的文件发送需要4次上下文切换和4次拷贝。**

## 零拷贝技术  
1. mmap+write  
`read()`系统调用的过程中会把内核缓冲区的数据拷贝至用户缓冲区。`mmap()`系统调用会将内和缓冲区与用户缓冲区做一个映射，形成共享缓冲区，这样，内核空间与用户空间之间就无需拷贝操作。  
· 系统调用`mmap()`，DMA将磁盘数据拷贝至内核缓冲区，然后应用程序和操作系统共享这一块缓冲区；  
· 系统调用`write()`，操作系统将内核数据拷贝至socket缓冲区；  
· 将socket缓冲区中的数据拷贝至网卡缓冲区，准备发送；  
**这种方法减少了一次数据拷贝，但不是理想情况，因为仍发生了4次上下文切换。**  
2. sendfile()  
`sendfile()`可以替代`read()`和`write()`这两个系统调用，这样就可以减少两次上下文切换；  
同时`sendfile()`直接将数据从内核态拷贝至socket；  
**实际上，在2.4之后的内核中，可以通过SG-DMA技术，直接将数据从内核缓冲区拷贝至网卡缓冲区，实现真真的零拷贝。**  

## PageCache
**前面说的内核缓冲区，实际上就是磁盘高速缓存。**  
PageCache的优点有2个：  
1. 根据局部性原理，缓存最近被访问的数据；  
2. 预读功能，假设`read()`每次读取32KB的数据，但内核会将整个64KB读取至PageCache；  
**但是在大文件传输的背景下，不应当使用PageCache。**

## 大文件传输
1. 小文件传输，采用零拷贝技术；  
2. 大文件传输，采用异步I/O+直接T/O的方式  
异步，是指应用程序发起I/O请求后可以去执行其它任务，等到文件拷贝结束后再进行下一步处理；  
直接，是指绕过PageCache，直接进行拷贝；